import{e as R}from"./index-BmhwsXu_.js";const C={"CODE NO":"CODE_NO",CODE_NO:"CODE_NO",CODENO:"CODE_NO","CODE NUMBER":"CODE_NO","FLAT NO":"CODE_NO",FLAT_NO:"CODE_NO","CHEQUE NO":"CHEQUE_NO",CHEQUE_NO:"CHEQUE_NO","CHQ NO":"CHEQUE_NO",CHQ_NO:"CHEQUE_NO","CHECK NO":"CHEQUE_NO","CHQ.DATE":"CHEQUE_DT","CHQ DATE":"CHEQUE_DT","CHEQUE DATE":"CHEQUE_DT",CHEQUE_DATE:"CHEQUE_DT",DATE:"CHEQUE_DT","NAME OF BANK":"BANK","BANK NAME":"BANK",BANK_NAME:"BANK",BANK:"BANK","RECEIPT AMOUNT":"REC_AMT",AMOUNT:"REC_AMT",REC_AMT:"REC_AMT","RECEIVED AMOUNT":"REC_AMT"};class O{constructor(){this.processingSummary={totalRecordsInFile:0,processedCodeNos:0,updatedRecords:0,skippedRecords:0,updatedColumns:[],recNoGenerated:0,recNoCleared:0,oldMaxRecNo:0,newMaxRecNo:0,codeNoInherited:0,warnings:[],errors:[]}}async processReceiptFile(e,o){try{console.log("üßæ Processing receipt file with Code No inheritance:",e.name),this.resetSummary();const s=await this.parseExcelFileWithInheritance(e);if(s.length===0)throw new Error("No data found in receipt file");this.processingSummary.totalRecordsInFile=s.length;const i=this.findMaxRecNo(o);this.processingSummary.oldMaxRecNo=i,console.log(`üìä Previous maximum REC_NO found: ${i} (will be cleared and regenerated)`);const n=this.groupReceiptsByCodeNo(s),t=this.updateCurrentDataWithReceipts(o,n,i);return console.log(`‚úÖ REC_NO regeneration completed. Cleared all old REC_NO values and generated ${this.processingSummary.recNoGenerated} new sequential receipt numbers.`),console.log(`üìà New sequential REC_NO range: ${i+1} to ${this.processingSummary.newMaxRecNo}`),console.log(`üîÑ Previous max was ${i}, now continuing sequential numbering from ${i+1}`),console.log(`üß¨ Code No inheritance: ${this.processingSummary.codeNoInherited} rows inherited Code No from previous row`),{success:!0,updatedData:t,processingSummary:this.processingSummary}}catch(s){return console.error("‚ùå Receipt processing error:",s),{success:!1,error:s.message,processingSummary:this.processingSummary}}}async parseExcelFileWithInheritance(e){try{const o=new R.Workbook;await o.xlsx.load(await e.arrayBuffer());const s=o.worksheets[0];if(!s)throw new Error("No worksheet found in Excel file");let i=null,n=0;for(let c=1;c<=Math.min(10,s.rowCount);c++){const m=s.getRow(c);let l=!1;if(m.eachCell((N,p)=>{const h=this.getCellValue(N);if(h&&typeof h=="string"){const E=h.toUpperCase().trim();Object.keys(C).some(g=>g===E)&&(l=!0)}}),l){i=m,n=c;break}}if(!i)throw new Error("Could not find header row with required columns (Code No, Cheque No, Chq.Date, Name of Bank, Receipt Amount)");const t=[];i.eachCell((c,m)=>{const l=this.getCellValue(c);l&&(t[m-1]=String(l).trim())}),this.validateRequiredColumns(t);const r=this.findCodeNoColumn(t),a=t.indexOf(r),u=[];let d=null;for(let c=n+1;c<=s.rowCount;c++){const m=s.getRow(c),l={};let N=!1;if(m.eachCell((p,h)=>{const E=t[h-1];if(E){const g=this.getCellValue(p);l[E]=g,g&&g!==0&&(N=!0)}}),N){const p=l[r];if(p&&p!==0&&String(p).trim()!=="")d=parseInt(p)||null,console.log(`üìç Found Code No: ${d} at row ${c}`);else if(d!==null)l[r]=d,this.processingSummary.codeNoInherited++,console.log(`üß¨ Inherited Code No: ${d} for row ${c}`),this.processingSummary.warnings.push(`Row ${c}: Missing Code No, inherited ${d} from previous row`);else{console.warn(`‚ö†Ô∏è Row ${c}: No Code No available (current or previous)`),this.processingSummary.warnings.push(`Row ${c}: No Code No found and no previous Code No to inherit - skipping row`);continue}l[r]&&u.push(l)}}return console.log(`üìä Parsed ${u.length} rows with ${this.processingSummary.codeNoInherited} Code No inheritances`),u}catch(o){throw new Error(`Failed to parse Excel file: ${o.message}`)}}findMaxRecNo(e){if(!e||e.length===0)return console.log("‚ö†Ô∏è No current data provided, starting REC_NO from 0"),0;try{const o=e.map(i=>{const n=i.REC_NO;if(n==null||n==="")return 0;const t=parseInt(n,10);return isNaN(t)?0:t}).filter(i=>i>0);if(o.length===0)return console.log("‚ö†Ô∏è No valid REC_NO values found in current data, starting from 0"),0;const s=Math.max(...o);return console.log(`üìä Found ${o.length} valid REC_NO values, maximum: ${s}`),s}catch(o){return console.error("‚ùå Error finding max REC_NO:",o),this.processingSummary.warnings.push(`Error finding max REC_NO: ${o.message}. Starting from 0.`),0}}getCellValue(e){if(!e||e.value===null||e.value===void 0)return"";if(typeof e.value=="string")return e.value.trim();if(e.value instanceof Date)return e.value.toISOString().split("T")[0];if(typeof e.value=="object"){if(e.value.result!==void 0)return e.value.result;if(e.value.text!==void 0)return e.value.text}return String(e.value)}validateRequiredColumns(e){const o=["CODE_NO","CHEQUE_NO","CHEQUE_DT","BANK","REC_AMT"],s=new Set;e.forEach(n=>{const t=n.toUpperCase().trim();C[t]&&s.add(C[t])});const i=o.filter(n=>!s.has(n));if(i.length>0){const n=i.map(t=>{switch(t){case"CODE_NO":return"Code No";case"CHEQUE_NO":return"Cheque No";case"CHEQUE_DT":return"Chq.Date";case"BANK":return"Name of Bank";case"REC_AMT":return"Receipt Amount";default:return t}});throw new Error(`Missing required columns: ${n.join(", ")}`)}}findCodeNoColumn(e){for(const o of e){const s=o.toUpperCase().trim();if(C[s]==="CODE_NO")return o}return null}normalizeReceiptData(e){return e.map(o=>{const s={};return Object.keys(o).forEach(i=>{const n=i.toUpperCase().trim(),t=C[n];if(t){let r=o[i];t==="CODE_NO"?r=parseInt(r)||0:t==="REC_AMT"?r=parseFloat(r)||0:t==="CHEQUE_DT"?r=this.normalizeDate(r):r=r?String(r).trim():"",s[t]=r}}),s})}normalizeDate(e){if(!e||e===0||e==="0"||e==="")return"";try{let o;if(console.log("üóìÔ∏è Normalizing date value:",e,"Type:",typeof e),typeof e=="number")o=new Date((e-25569)*86400*1e3),console.log("üìÖ Excel serial date converted:",o);else if(e instanceof Date)o=e,console.log("üìÖ Date object used directly:",o);else if(typeof e=="string"){const r=e.trim();if(console.log("üìÖ Processing string date:",r),r.includes("-")||r.includes("/")){const a=r.split(/[-\/]/);if(a.length===3)if(a[0].length===4)o=new Date(parseInt(a[0]),parseInt(a[1])-1,parseInt(a[2]));else if(a[2].length===4)o=new Date(parseInt(a[2]),parseInt(a[1])-1,parseInt(a[0]));else{const u=parseInt(a[0]),d=parseInt(a[1]),c=parseInt(a[2])+(parseInt(a[2])<50?2e3:1900);u>12?o=new Date(c,d-1,u):d>12?o=new Date(c,u-1,d):o=new Date(c,d-1,u)}}else if(r.includes(" ")){const a=r.split(" ");if(a.length===3){const u=parseInt(a[0]),d=a[1].toLowerCase(),c=parseInt(a[2]),l={jan:0,january:0,feb:1,february:1,mar:2,march:2,apr:3,april:3,may:4,jun:5,june:5,jul:6,july:6,aug:7,august:7,sep:8,september:8,oct:9,october:9,nov:10,november:10,dec:11,december:11}[d];l!==void 0?o=new Date(c,l,u):o=new Date(r)}else o=new Date(r)}else o=new Date(r)}else o=new Date(e);if(!o||isNaN(o.getTime()))return console.warn("‚ùå Invalid date after parsing:",e),String(e);const s=o.getDate().toString().padStart(2,"0"),i=(o.getMonth()+1).toString().padStart(2,"0"),n=o.getFullYear(),t=`${s}/${i}/${n}`;return console.log("‚úÖ Date normalized to:",t),t}catch(o){return console.warn("‚ùå Date parsing error:",o,"for value:",e),String(e)}}groupReceiptsByCodeNo(e){const o=this.normalizeReceiptData(e),s=new Map;o.forEach((n,t)=>{const r=n.CODE_NO;if(!r){this.processingSummary.warnings.push(`Row ${t+1}: Missing Code No, skipping`);return}s.has(r)||s.set(r,[]),s.get(r).push(n)});const i=new Map;return s.forEach((n,t)=>{n.length>3?(this.processingSummary.warnings.push(`Code No ${t}: Found ${n.length} rows, using first 3 rows only.`),n=n.slice(0,3)):n.length<3&&this.processingSummary.warnings.push(`Code No ${t}: Found ${n.length} rows, padding with empty rows.`);const r=[];for(let a=0;a<3;a++)a<n.length?r.push(n[a]):r.push({CODE_NO:t,CHEQUE_NO:"",CHEQUE_DT:"",BANK:"",REC_AMT:0});i.set(t,r),this.processingSummary.processedCodeNos++}),i}updateCurrentDataWithReceipts(e,o,s){const i=[...e],n=new Set;let t=s;return console.log("üîÑ Starting REC_NO regeneration process..."),console.log(`üìä Previous max REC_NO was: ${s}, will continue numbering from ${s+1}`),i.forEach(r=>{r.REC_NO=""}),console.log("üßπ Cleared all existing REC_NO values"),i.forEach((r,a)=>{const u=parseInt(r.CODE_NO);o.has(u)?(o.get(u).forEach((c,m)=>{const l=m+1;r[`CHEQUE_NO${l}`]=c.CHEQUE_NO||"",r[`CHEQUE_DT${l}`]=c.CHEQUE_DT||"",r[`BANK${l}`]=c.BANK||"",r[`REC_AMT${l}`]=c.REC_AMT||0,n.add(`CHEQUE_NO${l}`),n.add(`CHEQUE_DT${l}`),n.add(`BANK${l}`),n.add(`REC_AMT${l}`)}),this.processingSummary.updatedRecords++):this.processingSummary.skippedRecords++}),console.log(`üî¢ Regenerating REC_NO for all records with payment data, starting from ${s+1}...`),i.forEach((r,a)=>{this.hasAnyPaymentData(r)?(t++,r.REC_NO=t.toString(),n.add("REC_NO"),this.processingSummary.recNoGenerated++,console.log(`üßæ Assigned REC_NO ${t} to Code No ${r.CODE_NO} (has payments)`)):(r.REC_NO="",console.log(`‚ùå No REC_NO for Code No ${r.CODE_NO} (no payments)`))}),this.processingSummary.updatedColumns=Array.from(n),this.processingSummary.newMaxRecNo=t,this.processingSummary.oldMaxRecNo=s,this.processingSummary.recNoCleared=i.length,this.processingSummary.skippedRecords>0&&this.processingSummary.warnings.push(`${this.processingSummary.skippedRecords} records in main data had no matching receipt data`),this.processingSummary.warnings.push(`üîÑ Regenerated REC_NO values: cleared ${this.processingSummary.recNoCleared} records, assigned ${this.processingSummary.recNoGenerated} new sequential numbers (${s+1} to ${t})`),this.processingSummary.codeNoInherited>0&&this.processingSummary.warnings.push(`üß¨ Code No inheritance: ${this.processingSummary.codeNoInherited} rows inherited Code No from previous row`),console.log("‚úÖ Receipt processing with Code No inheritance completed:",this.processingSummary),i}hasAnyPaymentData(e){const o=["REC_AMT","REC_AMT1","REC_AMT2","REC_AMT3"];for(const s of o)if((parseFloat(e[s])||0)>0)return!0;return!1}resetSummary(){this.processingSummary={totalRecordsInFile:0,processedCodeNos:0,updatedRecords:0,skippedRecords:0,updatedColumns:[],recNoGenerated:0,recNoCleared:0,oldMaxRecNo:0,newMaxRecNo:0,codeNoInherited:0,warnings:[],errors:[]}}}const y=new O,w=async(f,e)=>await y.processReceiptFile(f,e);export{y as default,w as processReceiptFile};
